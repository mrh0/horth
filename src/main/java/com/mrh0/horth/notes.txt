0:RAX, 1:RBX, tmp0:R10, tmp1: R11, stackstart: R12

//Manipulators
swap:
    xchg    rax, rbx
swap2:
    xchg    rax, [rsp]
    xchg    rbx, [rsp-8]
rot:
    xchg    rax, [rsp]
over:
    xchg    rax, rbx
    push    rax
over2:
    push    rbx
    push    rax
    mov     rax, [rsp-16]
    mov     rbx, [rsp-24]
drop:
    mov     rax, rbx
    pop     rbx
drop2:
    pop     rax
    pop     rbx
drop3:
    pop     rax
    pop     rax
    pop     rbx
dup:
    push    rbx
    mov     rbx, rax
dup2x:                  //duplicates 2 times 'dup dup'
    push    rbx
    push    rax
    mov     rbx, rax
dup3x:                  //duplicates 3 times 'dup dup dup'
    push    rbx
    push    rax
    push    rax
    mov     rbx, rax
dup2s:                  //duplicates first 2 'dup2'
    push    rbx
    push    rax
dup3s:                  //duplicates first 3 'dup3'
    push    [rsp]
    push    rbx
    push    rax

//internal
put1:
    push    rbx
    mov     rbx, rax
    mov     rax, <i>
put2:
    push    rbx
    push    rax
    mov     rbx, <i>
    mov     rax, <i>
put3:
    push    rbx
    push    rax
    mov     r10, <i>
    push    r10
    mov     rbx, <i>
    mov     rax, <i>
put4:
    push    rbx
    push    rax
    mov     r10, <i>
    push    r10
    mov     r11, <i>
    push    r11
    mov     rbx, <i>
    mov     rax, <i>

//Operands
add:
    add     rax, rbx
    pop     rbx
add_i:
    add     <i>, rax

//Keywords
if:
    cmp     rax, 0
    mov     rax, rbx
    pop     rbx
    jle     <label>

lessThan:
    mov     rcx, 0
    mov     rdx, 1
    cmp     rbx, rax
    cmovl   rcx, rdx
    pop     rbx
    mov     rax, rcx

and:
    and     rax, rbx
    pop     rbx

local variables defined with let in a func will be put on a 'local stack' (not real rsp stack). Local variable sizes are summed and stored, when a func return it will pop the size from the 'local stack'.

error handling:
func test1 int int -> int throws string in
    -
    if 0 == do
        throw "This is a error" end
    end
end

func test2 int int -> int throws string in
    try test1 end
end
//ending the return list with a 'throws' declares that this function can throw an error
//if the top of the local stack is non-zero when test2 completes, test1 will throw the error further
//the top of the local stack could potentially be an error code or a pointer to an error string or exception struct

func test3 in
    catch test2 passed
        ...
    failed
        let error in
            error eputs
        end
    end
end

//a throws chain must at some point end with a catch (passed/threw)
