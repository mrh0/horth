
local variables defined with let in a func will be put on a 'local stack' (not real rsp stack). Local variable sizes are summed and stored, when a func return it will pop the size from the 'local stack'.

error handling:
func test1 int int -> int throws string in
    -
    if 0 == do
        throw "This is a error" end
    end
end

func test2 int int -> int throws string in
    try test1 end
end
//ending the return list with a 'throws' declares that this function can throw an error
//if the top of the local stack is non-zero when test2 completes, test1 will throw the error further
//the top of the local stack could potentially be an error code or a pointer to an error string, atom or exception struct

func test3 in
    catch test2 passed
        ...
    failed
        let error in
            error eputs
        end
    end
end

//a throws chain must at some point end with a catch (passed/threw)

//Lambda?:
x: y: x y +;
lambda ends with ';'?. Takes argument types from what consumes it.

fn x y in x y + end

//Define
func test int int -> int in ... end //1
//Overload
func test int void -> int in ... end //2
func test string int -> int in ... end //3
//Call 1
1 1 test
//Call 2
1 void test
//Call 3
"hello" 2 test

//Boxed types
func makeBox int -> boxed atom in
    if dup 0 == do
        "Hello World" box
    elif dup 1 == do
        500 box
    elif dup 2 == do
        'A' box
    else
        void box
end

func openBox int in
    makeBox
    let boxed type in
        if type :string == do
            boxed as string
            //Is string...
        if type :int == do
            boxed as int
            //Is int...
        if type :char == do
            boxed as char
            //Is char...
    end
end